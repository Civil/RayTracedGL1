// Copyright (c) 2021 Sultim Tsyrendashiev
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#version 460
#extension GL_EXT_ray_tracing : require

#define DESC_SET_FRAMEBUFFERS 1
#define DESC_SET_GLOBAL_UNIFORM 2
#define DESC_SET_VERTEX_DATA 3
#define DESC_SET_TEXTURES 4
#define DESC_SET_RANDOM 5
#include "ShaderCommonGLSLFunc.h"

layout(binding = BINDING_ACCELERATION_STRUCTURE, set = 0) uniform accelerationStructureEXT topLevelAS;

layout(location = PAYLOAD_INDEX_DEFAULT) rayPayloadEXT ShPayload payload;
layout(location = PAYLOAD_INDEX_SHADOW) rayPayloadEXT ShPayloadShadow payloadShadow;

float square(float x)
{
	return x * x;
}

// lightDirection is pointed to the light
bool castShadowRay(vec3 origin, vec3 lightDirection)
{
	// prepare shadow payload
	payloadShadow.isShadowed = 1;  
	
	traceRayEXT(
		topLevelAS, 
		gl_RayFlagsSkipClosestHitShaderEXT, 
		INSTANCE_MASK_HAS_SHADOWS, 
		0, 0, 	// sbtRecordOffset, sbtRecordStride
		SBT_INDEX_MISS_SHADOW, 		// shadow missIndex
		origin, 0.001, lightDirection, 10000.0, 
		PAYLOAD_INDEX_SHADOW);

	return payloadShadow.isShadowed == 1;
}

// subsurfaceAlbedo -- 0 if all light is absorbed,
//                     1 if no light is absorbed
float getBRDFLambertian(float subsurfaceAlbedo)
{
	return subsurfaceAlbedo / M_PI;
}

// nl -- cos between surface normal and light direction
// n1 -- refractive index of src media
// n2 -- refractive index of dst media
float getFresnelSchlick(float nl, float n1, float n2)
{
	float F0 = square((n1 - n2) / (n1 + n2));
	return F0 + (1 - F0) * pow(1 - max(nl, 0), 5);
}

// n -- macrosurface normal
// v -- direction to viewer
// l -- direction to light
// alpha -- roughness
float getBRDFSmithGGX(vec3 n, vec3 v, vec3 l, float alpha)
{
	float nl = dot(n, l);

	if (nl <= 0)
	{
		return 0;
	}

	vec3 h = normalize(v + l);

	nl = max(nl, 0);
	float nv = max(dot(n, v), 0);
	float nh = max(dot(n, h), 0);
	float nhSq = nh * nh;
	float nlSq = nl * nl;

	float alphaSq = alpha * alpha;

	float F = 1; // getFresnelSchlick(nl, n1, n2);
	float D = nh * alphaSq / (M_PI * square(1 + nhSq * (alphaSq - 1)));

	// approximation for SmithGGX, Hammon
	// inlcudes 1 / (4 * nl * nv)
	float G2Modif = 0.5 / mix(2 * nl * nv, nl + nv, alpha);

	return F * G2Modif * D;
}

struct ShDirectionalLight
{
	vec3 direction;
	float angularDiameter;
	vec3 color;
};

void processDirectionalLight(
	ivec2 pix, vec3 surfPosition, 
	vec3 surfNormal, vec3 surfNormalGeom,
	float roughness, vec3 viewDirection, 
	ShDirectionalLight dirLight,
	out vec3 outDiffuse, out vec3 outSpecular)
{
	uint seed = getCurrentRandomSeed(pix);
	vec2 disk = sampleDisk(seed, tan(dirLight.angularDiameter * 0.5));

	vec3 dir;
	{
		vec3 r = normalize(cross(dirLight.direction, vec3(0, 1, 0)));
		vec3 u = cross(r, dirLight.direction);
		dir = normalize(dirLight.direction + r * disk.x + u * disk.y);
	}

	float nl = dot(surfNormal, dir);
	float ngl = dot(surfNormalGeom,dir);

	if (nl <= 0 || ngl <= 0)
	{
		outDiffuse = vec3(0.0);
		outSpecular = vec3(0.0);
		return;
	}

	bool isShadowed = castShadowRay(surfPosition, dir);

	if (isShadowed)
	{
		outDiffuse = vec3(0.0);
		outSpecular = vec3(0.0);
		return;
	}

	outDiffuse = getBRDFLambertian(1.0) * dirLight.color * nl;
	outSpecular = getBRDFSmithGGX(surfNormal, viewDirection, dirLight.direction, roughness) * dirLight.color * nl;
}

void main()
{
	const ivec2 pix = ivec2(gl_LaunchIDEXT.xy);

	vec4 depth = texelFetch(framebufDepth_Sampler, pix, 0);

	if (depth.x > MAX_RAY_LENGTH - 1.0f)
	{
		vec4 skyColor = texelFetch(framebufAlbedo_Sampler, pix, 0);
		imageStore(framebufFinal, pix, skyColor);
		return;
	}
	
	vec4 surfPosition = texelFetch(framebufSurfacePosition_Sampler, pix, 0);
	vec4 surfNormal = texelFetch(framebufNormal_Sampler, pix, 0);
	vec4 surfNormalGeom = texelFetch(framebufNormalGeometry_Sampler, pix, 0);
	vec4 viewDirection = texelFetch(framebufViewDirection_Sampler, pix, 0);

	float roughness = 0.8;
	
	ShDirectionalLight lt;
	lt.direction = normalize(vec3(-1, 1, 1));
	lt.angularDiameter = 0.2;
	lt.color = vec3(5, 5, 5);

	vec3 diffuse, specular;
	processDirectionalLight(pix, surfPosition.xyz, surfNormal.xyz, surfNormalGeom.xyz, roughness, -viewDirection.xyz, lt, diffuse, specular);

	imageStore(framebufLightDirectDiffuse, pix, vec4(diffuse, 0.0));
	imageStore(framebufLightDirectSpecular, pix, vec4(specular, 0.0));


	// temp
	vec4 albedo = texelFetch(framebufAlbedo_Sampler, pix, 0);

	float specularity = 0.1;
	float ambient = 0.2;
	vec4 color = albedo * (vec4(diffuse, 0.0) * (1 - specularity) + vec4(specular, 0.0) * specularity) * (1 - ambient) + ambient;

	imageStore(framebufFinal, pix, color);
}