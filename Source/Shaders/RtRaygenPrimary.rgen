// Copyright (c) 2021 Sultim Tsyrendashiev
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#version 460
#extension GL_EXT_ray_tracing : require

layout (constant_id = 0) const uint maxAlbedoLayerCount = 0;
#define MATERIAL_MAX_ALBEDO_LAYERS maxAlbedoLayerCount

#define DESC_SET_TLAS 0
#define DESC_SET_FRAMEBUFFERS 1
#define DESC_SET_GLOBAL_UNIFORM 2
#define DESC_SET_VERTEX_DATA 3
#define DESC_SET_TEXTURES 4
#define DESC_SET_RANDOM 5
#define DESC_SET_LIGHT_SOURCES 6
#define DESC_SET_CUBEMAPS 7
#define DESC_SET_RENDER_CUBEMAP 8
#include "RaygenCommon.h"

vec3 getRayDir(vec2 inUV)
{
    inUV = inUV * 2.0 - 1.0;
    
    const vec4 target = globalUniform.invProjection * vec4(inUV.x, inUV.y, 1, 1);
    const vec4 rayDir = globalUniform.invView * vec4(normalize(target.xyz / target.w), 0);
    
    return rayDir.xyz;
}

vec2 getPixelUV()
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    return pixelCenter / vec2(gl_LaunchSizeEXT.xy);
}

void storeSky(const ivec2 pix, const vec3 rayDir, bool calculateSkyAndStoreToAlbedo, const vec3 throughput, float firstHitDepthNDC)
{
    if (calculateSkyAndStoreToAlbedo)
    {
        imageStoreAlbedoSky(                pix, getSkyPrimary(rayDir));
    }
    else
    {
        // resave sky albedo in a special format
        imageStoreAlbedoSky(                pix, texelFetchAlbedo(pix).rgb);
    }

    imageStoreNormal(                       pix, vec3(0.0));
    imageStoreNormalGeometry(               pix, vec3(0.0));
    imageStore(framebufMetallicRoughness,   pix, vec4(0.0));
    imageStore(framebufDepth,               pix, vec4(MAX_RAY_LENGTH * 2.0, 0.0, 0.0, firstHitDepthNDC));
    imageStore(framebufMotion,              pix, vec4(0.0));
    imageStore(framebufSurfacePosition,     pix, vec4(0.0));
    imageStore(framebufVisibilityBuffer,    pix, vec4(UINT32_MAX));
    imageStore(framebufViewDirection,       pix, vec4(rayDir, 0.0));
    imageStore(framebufThroughput,          pix, vec4(throughput, 0.0));
}

// Ray Tracing Gems II. Chapter 8: Reflection and Refraction Formulas
// Returns false, if total internal reflection
bool calcRefractionDirection(float n1, float n2, const vec3 I, const vec3 N, out vec3 T)
{
    float eta = n1 / n2; //  relative index of refraction
    float c1 = -dot(I, N); // cos(theta1)
    float w = eta * c1;
    float c2m = (w - eta) * (w + eta); // cos^2(theta2) - 1

    if (c2m < -1.0f)
    { 
        return false; // total internal reflection
    }

    T = eta * I + (w - sqrt(1.0f + c2m)) * N;
    return true;
}

void main() 
{
    const ivec2 pix = getCheckerboardPix(ivec2(gl_LaunchIDEXT.xy));
    const vec2 inUV = getPixelUV();

    const float AX = 1.0 / globalUniform.renderWidth;
    const float AY = 1.0 / globalUniform.renderHeight;

    vec3 rayDir   = getRayDir(inUV);
    const vec3 rayDirAX = getRayDir(inUV + vec2(AX, 0.0));
    const vec3 rayDirAY = getRayDir(inUV + vec2(0.0, AY));

    const uint randomSeed = getRandomSeed(pix, globalUniform.frameId, globalUniform.renderWidth, globalUniform.renderHeight);
    imageStore(framebufRandomSeed, pix, uvec4(randomSeed));
    
    
    const vec3 cameraOrigin = globalUniform.cameraPosition.xyz;
    ShPayload payload = tracePrimaryRay(cameraOrigin, rayDir);


    // was no hit
    if (!isPayloadConsistent(payload))
    {
        // if sky is a rasterized geometry, it was already rendered to albedo framebuf 
        storeSky(pix, rayDir, globalUniform.skyType != SKY_TYPE_RASTERIZED_GEOMETRY, vec3(1.0), MAX_RAY_LENGTH * 2.0);
        return;
    }


    vec2 motionCurToPrev;
    float motionDepthLinearCurToPrev;
    vec2 gradDepth;
    float firstHitDepthNDC;
    float screenEmission;
    ShHitInfo h = getHitInfoPrimaryRay(payload, cameraOrigin, rayDirAX, rayDirAY, 1.0, motionCurToPrev, motionDepthLinearCurToPrev, gradDepth, firstHitDepthNDC, screenEmission);


    vec3 throughput = vec3(1.0);
    float fullPathLength = h.linearDepth;
    uint currentRayMedia = globalUniform.cameraMediaType;
    bool wasSplit = false;


    throughput *= getMediaTransmittance(currentRayMedia, h.linearDepth);


    for (int i = 0; i < globalUniform.reflectRefractMaxDepth; i++)
    {
        const uint instIndex = unpackInstanceIdAndCustomIndex(payload.instIdAndIndex).y;

        if ((instIndex & INSTANCE_CUSTOM_INDEX_FLAG_REFLECT_REFRACT) == 0)
        {
            break;
        }

        const bool isPixOdd = isCheckerboardPixOdd(pix) != 0;

        const uint newRayMedia = currentRayMedia == MEDIA_TYPE_WATER ? MEDIA_TYPE_VACUUM : MEDIA_TYPE_WATER;
            /*(instIndex & INSTANCE_CUSTOM_INDEX_FLAG_WATER_ONLY_REFLECT) != 0 || (instIndex & INSTANCE_CUSTOM_INDEX_FLAG_WATER_REFLECT_REFRACT) != 0 ? MEDIA_TYPE_WATER :
            (instIndex & INSTANCE_CUSTOM_INDEX_FLAG_GLASS_REFLECT_REFRACT) != 0 ? MEDIA_TYPE_GLASS :
            MEDIA_TYPE_VACUUM;*/

        const float curIndexOfRefraction = getIndexOfRefraction(currentRayMedia);
        const float newIndexOfRefraction = getIndexOfRefraction(newRayMedia);

        const bool isPortal = false;
            //(instIndex & INSTANCE_CUSTOM_INDEX_FLAG_PORTAL) != 0 && i == 0;
        const bool toRefract = true;
            //(instIndex & INSTANCE_CUSTOM_INDEX_FLAG_WATER_REFLECT_REFRACT) != 0 || 
            //(instIndex & INSTANCE_CUSTOM_INDEX_FLAG_GLASS_REFLECT_REFRACT) != 0;
        const bool toReflect = true;
            //(instIndex & INSTANCE_CUSTOM_INDEX_FLAG_WATER_REFLECT_REFRACT) != 0 || 
            //(instIndex & INSTANCE_CUSTOM_INDEX_FLAG_GLASS_REFLECT_REFRACT) != 0 ||
            //(instIndex & INSTANCE_CUSTOM_INDEX_FLAG_WATER_ONLY_REFLECT) != 0;


        if (!toReflect && !toRefract && !isPortal)
        {
            break;
        }

        if (dot(h.normal, -rayDir) < 0.0)
        {
            h.normal *= -1;
        }
        //h.normal = normalize(h.normal + 0.2 * normalize(vec3(h.albedo.r - 0.5, h.albedo.b - 0.5, h.albedo.g - 0.5)));
           
        vec3 rayOrigin = h.hitPosition;
        bool doSplit = !wasSplit;
        bool doRefraction;
        vec3 refractionDir;
        float F;

        if (toRefract && calcRefractionDirection(curIndexOfRefraction, newIndexOfRefraction, rayDir, h.normal, refractionDir))
        {
            doRefraction = isPixOdd;
            F = getFresnelSchlick(curIndexOfRefraction, newIndexOfRefraction, -rayDir, h.normal);
        }
        else
        {
            // total internal reflection
            doRefraction = false;
            doSplit = false;
            F = 1.0;
        }
        
        if (doRefraction)
        {
            rayDir = refractionDir;
            throughput *= (1 - F);

            // change media
            currentRayMedia = newRayMedia;
        }
        else if (isPortal)
        {
            rayOrigin += globalUniform.portalOutputOffsetFromCamera.xyz;
            throughput *= h.albedo;
        }
        else
        {
            rayDir = reflect(rayDir, h.normal);
            throughput *= F;
        }

        if (doSplit)
        {
            throughput *= 2;
            wasSplit = true;
        }


        payload = traceReflectionRefractionRay(rayOrigin, rayDir, doRefraction, false);

        
        if (!isPayloadConsistent(payload))
        {
            storeSky(pix, rayDir, true, throughput, firstHitDepthNDC);
            return;  
        }

        float depthNDC;
        h = getHitInfoPrimaryRay(payload, cameraOrigin, rayDirAX, rayDirAY, 0.0, motionCurToPrev, motionDepthLinearCurToPrev, gradDepth, depthNDC, screenEmission);

        throughput *= getMediaTransmittance(currentRayMedia, h.linearDepth);
        fullPathLength += h.linearDepth;
    }


    imageStoreAlbedoSurface(                pix, h.albedo, screenEmission);
    imageStoreNormal(                       pix, h.normal);
    imageStoreNormalGeometry(               pix, h.normalGeom);
    imageStore(framebufMetallicRoughness,   pix, vec4(h.metallic, h.roughness, 0, 0));
    // save only the first hit's depth for rasterization, as reflections/refraction only may be losely represented via rasterization
    imageStore(framebufDepth,               pix, vec4(fullPathLength, gradDepth, firstHitDepthNDC));
    imageStore(framebufMotion,              pix, vec4(motionCurToPrev, motionDepthLinearCurToPrev, 0.0));
    imageStore(framebufSurfacePosition,     pix, vec4(h.hitPosition, uintBitsToFloat(h.instCustomIndex)));
    imageStore(framebufVisibilityBuffer,    pix, packVisibilityBuffer(payload));
    imageStore(framebufViewDirection,       pix, vec4(rayDir, 0.0));
    imageStore(framebufThroughput,          pix, vec4(throughput, 0.0));
}
